# VM
## 실행 순서
initd
    -> supplemental_page_table_init
        -> hash_init
            ->hash_clear
        -> page_hash
        -> page_less
    -> process_exec
        -> process_cleanup
            -> susplemental_page_table_kill
        -> supplemental_page_table_init
        -> load
            -> pml4_create
            -> load_segment
                -> vm_alloc_page_with_initializer : file 정보를 page 구조체에 저장 후 spt에 추가. load를 위한 준비과정
                    -> spt_find_page
                        -> hash_find
                        -> free
                    -> uninit_new
                        -> *page 에 lazy_load_segment 들어감 (언제 실행?)
                    -> spt_insert_page
                        -> insert_page
                            -> hash_insert
                                -> find_bucket
                                -> find_elem
                                -> insert_elem
                                -> rehash
                                    -> list_init(&new_buckets)
            -> setup_stack
                -> palloc_get_page
                -> install_page
                -> palloc_free_page
        -> do_iret : thread switching

page_fault
    -> vm_try_handle_fault : page fault 발생시 핸들링 위해 호출되는 함수.
        -> vm_claim_page : 페이지 찾고 
            -> spt_find_page
                -> hash_find
                    -> find_bucket
                    -> find_elem
            -> vm_do_claim_page : frame 얻고 VA to PA mapping 
                -> vm_get_frame
                    -> palloc_get_page
                    -> vm_evict_frame
                -> install_page
                    -> pml4_get_page : user VA를 이용하여 PA확인. 있으면 kva return 없으면 NULL 반환
                    -> pml4_set_page : pml4의 UPAGE(V) to PF(KPAGE에 의해 확인된) mapping, 마지막 argu가 1이면 set
                -> swap_in
        

## 구조체

struct page {
	const struct page_operations *operations;
	void *va;              /* Address in terms of user space */
	struct frame *frame;   /* Back reference for frame */ // page frame
	bool writable;	/* True일경우해당주소에write 가능 False일경우해당주소에write 불가능*/

	struct hash_elem hash_elem;	// 해시 테이블 element

	union {
		struct uninit_page uninit;
		struct anon_page anon;
		struct file_page file;
}};

struct hash_elem {
	struct list_elem list_elem;
};

struct supplemental_page_table {
	struct hash pages;
};


struct hash {
	size_t elem_cnt;            /* Number of elements in table. */
	size_t bucket_cnt;          /* Number of buckets, a power of 2. */
	struct list *buckets;       /* Array of `bucket_cnt' lists. */
	hash_hash_func *hash;       /* Hash function. */
	hash_less_func *less;       /* Comparison function. */
	void *aux;                  /* Auxiliary data for `hash' and `less'. */
};

typedef uint64_t hash_hash_func (const struct hash_elem *e, void *aux);

typedef bool hash_less_func (const struct hash_elem *a,
		const struct hash_elem *b, void *aux);

struct hash_iterator {
	struct hash *hash;          /* The hash table. */
	struct list *bucket;        /* Current bucket. */
	struct hash_elem *elem;     /* Current hash element in current bucket. */
};